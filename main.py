
from collections.abc import Sequence
import multiprocessing

import numpy as np
import matplotlib.pyplot as plt

from torch import nn


from cubes import *
from sequences import MoveSequence
from solvers import *



## Miscellaneous ###################################################################################


_progressbarCnt = -1

def progressbar(message, current, final, length=100):
	global _progressbarCnt
	cnt = round(current * length / final)
	if cnt != _progressbarCnt:
		_progressbarCnt = cnt
		print(f"\r{message}[{'#'*cnt}{'-'*(length-cnt)}]", end="", flush=True)
		if cnt == length:
			print()



## Metrics for solver evaluation ###################################################################


class SuccessRateMetric:
	"""
	Generates `samples` starting positions scrambled by `scramblingMoves` moves,
	measures how often can the solver reach solved position.
	`scramblingMoves` can be a list (a list of sucess rates is returned then).
	"""

	def __init__(self, scramblingMoves, samples=100, seqLength=100, threads=1):
		self._multipleCounts = isinstance(scramblingMoves, Sequence)
		self.scramblingMoves = scramblingMoves if self._multipleCounts else [scramblingMoves]
		self.samples = samples
		self.seqLength = seqLength
		self.threads = threads

	def __call__(self, solver):
		rates = []
		for scMoveCount in self.scramblingMoves:

			if self.threads > 1:
				threadSamples = (self.samples+self.threads-1) // self.threads
				worker = _SuccessRateWorker(solver, threadSamples, scMoveCount, self.seqLength)
				with multiprocessing.Pool(self.threads) as pool:
					numsSolved = pool.map(worker, range(self.threads))
				successRate = sum(numsSolved) / (self.threads*threadSamples)

			else:
				numSolved = 0
				for seqInd in range(self.samples):
					seq = solver.generateSequence(numMoves=self.seqLength, init=[
						CubeTransform(CubeTransformMethod.reset, {}),
						CubeTransform(CubeTransformMethod.scramble, {"moves": scMoveCount}),
					])
					if seq.isSolved():
						numSolved += 1
				successRate = numSolved / self.samples

			rates.append(successRate)

		return rates if isinstance(self.scramblingMoves, Sequence) else rates[0]


class _SuccessRateWorker:
	"""
	A multiprocessing worker to parallelize `SuccessRateMetric`.
	Mostly good for solvers which are not parallel themselves, and are picklable.
	"""

	def __init__(self, solver, numSamples, scramblingMoves, seqLength):
		self.solver = solver
		self.numSamples = numSamples
		self.scramblingMoves = scramblingMoves
		self.seqLength = seqLength

	def __call__(self, _):
		numSolved = 0
		for seqInd in range(self.numSamples):
			seq = self.solver.generateSequence(numMoves=self.seqLength, init=[
				CubeTransform(CubeTransformMethod.reset, {}),
				CubeTransform(CubeTransformMethod.scramble, {"moves": self.scramblingMoves}),
			])
			if seq.isSolved():
				numSolved += 1
		return numSolved



## Training methods ################################################################################


def train(
	solver,
	trainingSeqCount,
	trainingSeqGenerator,
):
	"""
	Feeds sequences generated by `trainingSetGenerator`
	into the `trainOnSequence` method of `solver`
	"""
	for seqInd in range(trainingSeqCount):
		progressbar("train: ", seqInd+1, trainingSeqCount)
		seq = trainingSeqGenerator(solver)
		solver.trainOnSequence(seq)


def dependencyOnTrainingData(
	solver,
	trainingSeqCounts, # growing sequence expected (describes cumulative training)
	trainingSeqGenerator, # function(solver) -> MoveSequence
	metrics, # dict of "metric name": function(solver) -> value
):
	"""
	The same training routine as `train`, interrupted by metric evaluations
	"""
	metricValues = { name: [] for name in metrics.keys() }
	seqInd = 0
	for nextSeqCnt in trainingSeqCounts:

		# training
		for seqInd in range(seqInd, nextSeqCnt):
			progressbar("measure: ", seqInd+1, trainingSeqCounts[-1])
			seq = trainingSeqGenerator(solver)
			solver.trainOnSequence(seq)

		# measurement
		for name, metric in metrics.items():
			value = metric(solver)
			metricValues[name].append(value)

	return metricValues



## Experiments #####################################################################################


np.random.seed(1)


canonization = {
	"rotationEquivalent": True,
	"colorSwapEquivalent": 1,
}

cube = Rubik_2x2x2()
#cube = Rubik_2x2x2(fixCorner=True)

#cube.repl()



## Counting reachable positions ############################

#total = 0
#for numMoves, positions in enumerate(cube.getPositionsAfter(15, **canonization)):
#	new = len(positions)
#	total += new
#	print(f"{numMoves} moves: {new} new positions, {total} total")



## Define a solver #########################################


#solver = MemorizeSolver(cube, canonization)


solver = TorchMLPSolver(cube, canonization)

solver.setModel(nn.Sequential(
	nn.Linear(solver.numFeatures, 50),
	nn.ReLU(),
	nn.Linear(50, 50),
	nn.ReLU(),
	nn.Linear(50, solver.numMoves),
))

optimizer = torch.optim.Adam(solver.getParam(), lr=1e-3)
solver.setOptimizer(optimizer)

milestones = [10, 30, 100, 300, 1000, 3000]
scheduler = torch.optim.lr_scheduler.MultiStepLR(
	optimizer,
	milestones = milestones,
	gamma = 0.5,
)
solver.setScheduler(scheduler)



## Train the solver ########################################

def trainSeqGen(solver):
	randomSolver = RandomSolver(solver.cube)
	seq = randomSolver.generateSequence(
		numMoves = 10,
		init = CubeTransform(CubeTransformMethod.reset, {}),
	)
	return seq.invert().canonize(**canonization).check()

seqCounts = np.arange(0, 50001, 2500)
metricValues = dependencyOnTrainingData(
	solver,
	seqCounts,
	trainSeqGen,
	{
		"success rate 5":  SuccessRateMetric( 5, 5000, threads=6),
		"success rate 10": SuccessRateMetric(10, 5000, threads=6),
		"success rate 20": SuccessRateMetric(20, 5000, threads=6),
	},
)

for name, values in metricValues.items():
	plt.plot(seqCounts, values, label=name)
plt.ylim(0, 1)
plt.grid()
plt.legend()
plt.show()

breakpoint()



## Visualize solver runs ###################################

while True:
	seq = solver.generateSequence(numMoves=100, init=[
		CubeTransform(CubeTransformMethod.reset, {}),
		CubeTransform(CubeTransformMethod.scramble, {"moves": 9}),
	])
	seq = seq.simplify()
	seq.check()
	seq.animate()
	plt.show() # keep matplotlib window open

